{"version":3,"file":"bufferedData-Bfc_pTqn.js","sources":["../../node_modules/@datadog/browser-core/esm/tools/instrumentMethod.js","../../node_modules/@datadog/browser-core/esm/domain/error/trackRuntimeError.js","../../node_modules/@datadog/browser-core/esm/boot/init.js","../../node_modules/@datadog/browser-core/esm/boot/displayAlreadyInitializedError.js","../../node_modules/@datadog/browser-core/esm/domain/report/reportObservable.js","../../node_modules/@datadog/browser-core/esm/domain/tags.js","../../node_modules/@datadog/browser-core/esm/tools/sendToExtension.js","../../node_modules/@datadog/browser-core/esm/tools/mergeInto.js","../../node_modules/@datadog/browser-core/esm/domain/connectivity/connectivity.js","../../node_modules/@datadog/browser-core/esm/tools/utils/responseUtils.js","../../node_modules/@datadog/browser-core/esm/transport/sendWithRetryStrategy.js","../../node_modules/@datadog/browser-core/esm/transport/httpRequest.js","../../node_modules/@datadog/browser-core/esm/transport/eventBridge.js","../../node_modules/@datadog/browser-core/esm/browser/pageMayExitObservable.js","../../node_modules/@datadog/browser-core/esm/transport/batch.js","../../node_modules/@datadog/browser-core/esm/transport/flushController.js","../../node_modules/@datadog/browser-core/esm/tools/abstractHooks.js","../../node_modules/@datadog/browser-core/esm/domain/telemetry/rawTelemetryEvent.types.js","../../node_modules/@datadog/browser-core/esm/domain/telemetry/telemetry.js","../../node_modules/@datadog/browser-core/esm/tools/utils/arrayUtils.js","../../node_modules/@datadog/browser-core/esm/tools/valueHistory.js","../../node_modules/@datadog/browser-core/esm/domain/synthetics/syntheticsWorkerValues.js","../../node_modules/@datadog/browser-core/esm/domain/session/sessionManager.js","../../node_modules/@datadog/browser-core/esm/tools/encoder.js","../../node_modules/@datadog/browser-core/esm/tools/abstractLifeCycle.js","../../node_modules/@datadog/browser-core/esm/domain/eventRateLimiter/createEventRateLimiter.js","../../node_modules/@datadog/browser-core/esm/browser/xhrObservable.js","../../node_modules/@datadog/browser-core/esm/tools/readBytesFromStream.js","../../node_modules/@datadog/browser-core/esm/browser/fetchObservable.js","../../node_modules/@datadog/browser-core/esm/domain/console/consoleObservable.js","../../node_modules/@datadog/browser-core/esm/tools/boundedBuffer.js","../../node_modules/@datadog/browser-core/esm/domain/context/contextUtils.js","../../node_modules/@datadog/browser-core/esm/domain/context/contextManager.js","../../node_modules/@datadog/browser-core/esm/domain/context/defineContextMethod.js","../../node_modules/@datadog/browser-core/esm/domain/context/storeContextManager.js","../../node_modules/@datadog/browser-core/esm/domain/contexts/accountContext.js","../../node_modules/@datadog/browser-core/esm/domain/contexts/globalContext.js","../../node_modules/@datadog/browser-core/esm/domain/contexts/userContext.js","../../node_modules/@datadog/browser-core/esm/domain/context/contextConstants.js","../../node_modules/@datadog/browser-core/esm/domain/bufferedData.js"],"sourcesContent":["import { setTimeout } from './timer';\nimport { callMonitored } from './monitor';\nimport { noop } from './utils/functionUtils';\nimport { createHandlingStack } from './stackTrace/handlingStack';\n/**\n * Instruments a method on a object, calling the given callback before the original method is\n * invoked. The callback receives an object with information about the method call.\n *\n * This function makes sure that we are \"good citizens\" regarding third party instrumentations: when\n * removing the instrumentation, the original method is usually restored, but if a third party\n * instrumentation was set after ours, we keep it in place and just replace our instrumentation with\n * a noop.\n *\n * Note: it is generally better to instrument methods that are \"owned\" by the object instead of ones\n * that are inherited from the prototype chain. Example:\n * * do:    `instrumentMethod(Array.prototype, 'push', ...)`\n * * don't: `instrumentMethod([], 'push', ...)`\n *\n * This method is also used to set event handler properties (ex: window.onerror = ...), as it has\n * the same requirements as instrumenting a method:\n * * if the event handler is already set by a third party, we need to call it and not just blindly\n * override it.\n * * if the event handler is set by a third party after us, we need to keep it in place when\n * removing ours.\n *\n * @example\n *\n *  instrumentMethod(window, 'fetch', ({ target, parameters, onPostCall }) => {\n *    console.log('Before calling fetch on', target, 'with parameters', parameters)\n *\n *    onPostCall((result) => {\n *      console.log('After fetch calling on', target, 'with parameters', parameters, 'and result', result)\n *    })\n *  })\n */\nexport function instrumentMethod(targetPrototype, method, onPreCall, { computeHandlingStack } = {}) {\n    let original = targetPrototype[method];\n    if (typeof original !== 'function') {\n        if (method in targetPrototype && method.startsWith('on')) {\n            original = noop;\n        }\n        else {\n            return { stop: noop };\n        }\n    }\n    let stopped = false;\n    const instrumentation = function () {\n        if (stopped) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-call\n            return original.apply(this, arguments);\n        }\n        const parameters = Array.from(arguments);\n        let postCallCallback;\n        callMonitored(onPreCall, null, [\n            {\n                target: this,\n                parameters,\n                onPostCall: (callback) => {\n                    postCallCallback = callback;\n                },\n                handlingStack: computeHandlingStack ? createHandlingStack('instrumented method') : undefined,\n            },\n        ]);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const result = original.apply(this, parameters);\n        if (postCallCallback) {\n            callMonitored(postCallCallback, null, [result]);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return result;\n    };\n    targetPrototype[method] = instrumentation;\n    return {\n        stop: () => {\n            stopped = true;\n            // If the instrumentation has been removed by a third party, keep the last one\n            if (targetPrototype[method] === instrumentation) {\n                targetPrototype[method] = original;\n            }\n        },\n    };\n}\nexport function instrumentSetter(targetPrototype, property, after) {\n    const originalDescriptor = Object.getOwnPropertyDescriptor(targetPrototype, property);\n    if (!originalDescriptor || !originalDescriptor.set || !originalDescriptor.configurable) {\n        return { stop: noop };\n    }\n    const stoppedInstrumentation = noop;\n    let instrumentation = (target, value) => {\n        // put hooked setter into event loop to avoid of set latency\n        setTimeout(() => {\n            if (instrumentation !== stoppedInstrumentation) {\n                after(target, value);\n            }\n        }, 0);\n    };\n    const instrumentationWrapper = function (value) {\n        originalDescriptor.set.call(this, value);\n        instrumentation(this, value);\n    };\n    Object.defineProperty(targetPrototype, property, {\n        set: instrumentationWrapper,\n    });\n    return {\n        stop: () => {\n            var _a;\n            if (((_a = Object.getOwnPropertyDescriptor(targetPrototype, property)) === null || _a === void 0 ? void 0 : _a.set) === instrumentationWrapper) {\n                Object.defineProperty(targetPrototype, property, originalDescriptor);\n            }\n            instrumentation = stoppedInstrumentation;\n        },\n    };\n}\n//# sourceMappingURL=instrumentMethod.js.map","import { instrumentMethod } from '../../tools/instrumentMethod';\nimport { Observable } from '../../tools/observable';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nimport { computeStackTraceFromOnErrorMessage } from '../../tools/stackTrace/computeStackTrace';\nimport { getGlobalObject } from '../../tools/globalObject';\nimport { computeRawError, isError } from './error';\nimport { ErrorSource } from './error.types';\nexport function trackRuntimeError() {\n    return new Observable((observer) => {\n        const handleRuntimeError = (originalError, stackTrace) => {\n            const rawError = computeRawError({\n                stackTrace,\n                originalError,\n                startClocks: clocksNow(),\n                nonErrorPrefix: \"Uncaught\" /* NonErrorPrefix.UNCAUGHT */,\n                source: ErrorSource.SOURCE,\n                handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n            });\n            observer.notify(rawError);\n        };\n        const { stop: stopInstrumentingOnError } = instrumentOnError(handleRuntimeError);\n        const { stop: stopInstrumentingOnUnhandledRejection } = instrumentUnhandledRejection(handleRuntimeError);\n        return () => {\n            stopInstrumentingOnError();\n            stopInstrumentingOnUnhandledRejection();\n        };\n    });\n}\nexport function instrumentOnError(callback) {\n    return instrumentMethod(getGlobalObject(), 'onerror', ({ parameters: [messageObj, url, line, column, errorObj] }) => {\n        let stackTrace;\n        if (!isError(errorObj)) {\n            stackTrace = computeStackTraceFromOnErrorMessage(messageObj, url, line, column);\n        }\n        callback(errorObj !== null && errorObj !== void 0 ? errorObj : messageObj, stackTrace);\n    });\n}\nexport function instrumentUnhandledRejection(callback) {\n    return instrumentMethod(getGlobalObject(), 'onunhandledrejection', ({ parameters: [e] }) => {\n        callback(e.reason || 'Empty reason');\n    });\n}\n//# sourceMappingURL=trackRuntimeError.js.map","import { catchUserErrors } from '../tools/catchUserErrors';\nimport { setDebugMode } from '../tools/monitor';\nimport { display } from '../tools/display';\nexport function makePublicApi(stub) {\n    const publicApi = {\n        version: \"6.24.1\",\n        // This API method is intentionally not monitored, since the only thing executed is the\n        // user-provided 'callback'.  All SDK usages executed in the callback should be monitored, and\n        // we don't want to interfere with the user uncaught exceptions.\n        onReady(callback) {\n            callback();\n        },\n        ...stub,\n    };\n    // Add a \"hidden\" property to set debug mode. We define it that way to hide it\n    // as much as possible but of course it's not a real protection.\n    Object.defineProperty(publicApi, '_setDebug', {\n        get() {\n            return setDebugMode;\n        },\n        enumerable: false,\n    });\n    return publicApi;\n}\nexport function defineGlobal(global, name, api) {\n    const existingGlobalVariable = global[name];\n    if (existingGlobalVariable && !existingGlobalVariable.q && existingGlobalVariable.version) {\n        display.warn('SDK is loaded more than once. This is unsupported and might have unexpected behavior.');\n    }\n    global[name] = api;\n    if (existingGlobalVariable && existingGlobalVariable.q) {\n        existingGlobalVariable.q.forEach((fn) => catchUserErrors(fn, 'onReady callback threw an error:')());\n    }\n}\n//# sourceMappingURL=init.js.map","import { display } from '../tools/display';\nexport function displayAlreadyInitializedError(sdkName, initConfiguration) {\n    if (!initConfiguration.silentMultipleInit) {\n        display.error(`${sdkName} is already initialized.`);\n    }\n}\n//# sourceMappingURL=displayAlreadyInitializedError.js.map","import { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { monitor } from '../../tools/monitor';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { addEventListener } from '../../browser/addEventListener';\nimport { safeTruncate } from '../../tools/utils/stringUtils';\nimport { ErrorSource } from '../error/error.types';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nexport const RawReportType = {\n    intervention: 'intervention',\n    deprecation: 'deprecation',\n    cspViolation: 'csp_violation',\n};\nexport function initReportObservable(configuration, apis) {\n    const observables = [];\n    if (apis.includes(RawReportType.cspViolation)) {\n        observables.push(createCspViolationReportObservable(configuration));\n    }\n    const reportTypes = apis.filter((api) => api !== RawReportType.cspViolation);\n    if (reportTypes.length) {\n        observables.push(createReportObservable(reportTypes));\n    }\n    return mergeObservables(...observables);\n}\nfunction createReportObservable(reportTypes) {\n    return new Observable((observable) => {\n        if (!window.ReportingObserver) {\n            return;\n        }\n        const handleReports = monitor((reports, _) => reports.forEach((report) => observable.notify(buildRawReportErrorFromReport(report))));\n        const observer = new window.ReportingObserver(handleReports, {\n            types: reportTypes,\n            buffered: true,\n        });\n        observer.observe();\n        return () => {\n            observer.disconnect();\n        };\n    });\n}\nfunction createCspViolationReportObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop } = addEventListener(configuration, document, \"securitypolicyviolation\" /* DOM_EVENT.SECURITY_POLICY_VIOLATION */, (event) => {\n            observable.notify(buildRawReportErrorFromCspViolation(event));\n        });\n        return stop;\n    });\n}\nfunction buildRawReportErrorFromReport(report) {\n    const { type, body } = report;\n    return buildRawReportError({\n        type: body.id,\n        message: `${type}: ${body.message}`,\n        originalError: report,\n        stack: buildStack(body.id, body.message, body.sourceFile, body.lineNumber, body.columnNumber),\n    });\n}\nfunction buildRawReportErrorFromCspViolation(event) {\n    const message = `'${event.blockedURI}' blocked by '${event.effectiveDirective}' directive`;\n    return buildRawReportError({\n        type: event.effectiveDirective,\n        message: `${RawReportType.cspViolation}: ${message}`,\n        originalError: event,\n        csp: {\n            disposition: event.disposition,\n        },\n        stack: buildStack(event.effectiveDirective, event.originalPolicy\n            ? `${message} of the policy \"${safeTruncate(event.originalPolicy, 100, '...')}\"`\n            : 'no policy', event.sourceFile, event.lineNumber, event.columnNumber),\n    });\n}\nfunction buildRawReportError(partial) {\n    return {\n        startClocks: clocksNow(),\n        source: ErrorSource.REPORT,\n        handling: \"unhandled\" /* ErrorHandling.UNHANDLED */,\n        ...partial,\n    };\n}\nfunction buildStack(name, message, sourceFile, lineNumber, columnNumber) {\n    return sourceFile\n        ? toStackTraceString({\n            name,\n            message,\n            stack: [\n                {\n                    func: '?',\n                    url: sourceFile,\n                    line: lineNumber !== null && lineNumber !== void 0 ? lineNumber : undefined,\n                    column: columnNumber !== null && columnNumber !== void 0 ? columnNumber : undefined,\n                },\n            ],\n        })\n        : undefined;\n}\n//# sourceMappingURL=reportObservable.js.map","import { DOCS_ORIGIN, MORE_DETAILS, display } from '../tools/display';\nexport const TAG_SIZE_LIMIT = 200;\nexport function buildTags(configuration) {\n    const { env, service, version, datacenter, sdkVersion, variant } = configuration;\n    const tags = [buildTag('sdk_version', sdkVersion !== null && sdkVersion !== void 0 ? sdkVersion : \"6.24.1\")];\n    if (env) {\n        tags.push(buildTag('env', env));\n    }\n    if (service) {\n        tags.push(buildTag('service', service));\n    }\n    if (version) {\n        tags.push(buildTag('version', version));\n    }\n    if (datacenter) {\n        tags.push(buildTag('datacenter', datacenter));\n    }\n    if (variant) {\n        tags.push(buildTag('variant', variant));\n    }\n    return tags;\n}\nexport function buildTag(key, rawValue) {\n    // See https://docs.datadoghq.com/getting_started/tagging/#defining-tags for tags syntax. Note\n    // that the backend may not follow the exact same rules, so we only want to display an informal\n    // warning.\n    const tag = rawValue ? `${key}:${rawValue}` : key;\n    if (tag.length > TAG_SIZE_LIMIT || hasForbiddenCharacters(tag)) {\n        display.warn(`Tag ${tag} doesn't meet tag requirements and will be sanitized. ${MORE_DETAILS} ${DOCS_ORIGIN}/getting_started/tagging/#defining-tags`);\n    }\n    // Let the backend do most of the sanitization, but still make sure multiple tags can't be crafted\n    // by forging a value containing commas.\n    return sanitizeTag(tag);\n}\nexport function sanitizeTag(tag) {\n    return tag.replace(/,/g, '_');\n}\nfunction hasForbiddenCharacters(rawValue) {\n    // Unicode property escapes is not supported in all browsers, so we use a try/catch.\n    // Todo: Remove the try/catch when dropping support for Chrome 63 and Firefox 67\n    // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#browser_compatibility\n    if (!supportUnicodePropertyEscapes()) {\n        return false;\n    }\n    // We use the Unicode property escapes to match any character that is a letter including other languages like Chinese, Japanese, etc.\n    // p{Ll} matches a lowercase letter.\n    // p{Lo} matches a letter that is neither uppercase nor lowercase (ex: Japanese characters).\n    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Unicode_character_class_escape#unicode_property_escapes_vs._character_classes\n    return new RegExp('[^\\\\p{Ll}\\\\p{Lo}0-9_:./-]', 'u').test(rawValue);\n}\nexport function supportUnicodePropertyEscapes() {\n    try {\n        new RegExp('[\\\\p{Ll}]', 'u');\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n//# sourceMappingURL=tags.js.map","import { globalObject } from './globalObject';\nexport function sendToExtension(type, payload) {\n    const callback = globalObject.__ddBrowserSdkExtensionCallback;\n    if (callback) {\n        callback({ type, payload });\n    }\n}\n//# sourceMappingURL=sendToExtension.js.map","import { getType } from './utils/typeUtils';\n/**\n * Iterate over source and affect its sub values into destination, recursively.\n * If the source and destination can't be merged, return source.\n */\nexport function mergeInto(destination, source, circularReferenceChecker = createCircularReferenceChecker()) {\n    // ignore the source if it is undefined\n    if (source === undefined) {\n        return destination;\n    }\n    if (typeof source !== 'object' || source === null) {\n        // primitive values - just return source\n        return source;\n    }\n    else if (source instanceof Date) {\n        return new Date(source.getTime());\n    }\n    else if (source instanceof RegExp) {\n        const flags = source.flags ||\n            // old browsers compatibility\n            [\n                source.global ? 'g' : '',\n                source.ignoreCase ? 'i' : '',\n                source.multiline ? 'm' : '',\n                source.sticky ? 'y' : '',\n                source.unicode ? 'u' : '',\n            ].join('');\n        return new RegExp(source.source, flags);\n    }\n    if (circularReferenceChecker.hasAlreadyBeenSeen(source)) {\n        // remove circular references\n        return undefined;\n    }\n    else if (Array.isArray(source)) {\n        const merged = Array.isArray(destination) ? destination : [];\n        for (let i = 0; i < source.length; ++i) {\n            merged[i] = mergeInto(merged[i], source[i], circularReferenceChecker);\n        }\n        return merged;\n    }\n    const merged = getType(destination) === 'object' ? destination : {};\n    for (const key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            merged[key] = mergeInto(merged[key], source[key], circularReferenceChecker);\n        }\n    }\n    return merged;\n}\n/**\n * A simplistic implementation of a deep clone algorithm.\n * Caveats:\n * - It doesn't maintain prototype chains - don't use with instances of custom classes.\n * - It doesn't handle Map and Set\n */\nexport function deepClone(value) {\n    return mergeInto(undefined, value);\n}\nexport function combine(...sources) {\n    let destination;\n    for (const source of sources) {\n        // Ignore any undefined or null sources.\n        if (source === undefined || source === null) {\n            continue;\n        }\n        destination = mergeInto(destination, source);\n    }\n    return destination;\n}\nfunction createCircularReferenceChecker() {\n    if (typeof WeakSet !== 'undefined') {\n        const set = new WeakSet();\n        return {\n            hasAlreadyBeenSeen(value) {\n                const has = set.has(value);\n                if (!has) {\n                    set.add(value);\n                }\n                return has;\n            },\n        };\n    }\n    const array = [];\n    return {\n        hasAlreadyBeenSeen(value) {\n            const has = array.indexOf(value) >= 0;\n            if (!has) {\n                array.push(value);\n            }\n            return has;\n        },\n    };\n}\n//# sourceMappingURL=mergeInto.js.map","import { globalObject } from '../../tools/globalObject';\nexport function getConnectivity() {\n    var _a;\n    const navigator = globalObject.navigator;\n    return {\n        status: navigator.onLine ? 'connected' : 'not_connected',\n        interfaces: navigator.connection && navigator.connection.type ? [navigator.connection.type] : undefined,\n        effective_type: (_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.effectiveType,\n    };\n}\n//# sourceMappingURL=connectivity.js.map","export function isServerError(status) {\n    return status >= 500;\n}\nexport function tryToClone(response) {\n    try {\n        return response.clone();\n    }\n    catch (_a) {\n        // clone can throw if the response has already been used by another instrumentation or is disturbed\n        return;\n    }\n}\n//# sourceMappingURL=responseUtils.js.map","import { setTimeout } from '../tools/timer';\nimport { clocksNow, ONE_MINUTE, ONE_SECOND } from '../tools/utils/timeUtils';\nimport { ONE_MEBI_BYTE, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { isServerError } from '../tools/utils/responseUtils';\nimport { ErrorSource } from '../domain/error/error.types';\nexport const MAX_ONGOING_BYTES_COUNT = 80 * ONE_KIBI_BYTE;\nexport const MAX_ONGOING_REQUESTS = 32;\nexport const MAX_QUEUE_BYTES_COUNT = 20 * ONE_MEBI_BYTE;\nexport const MAX_BACKOFF_TIME = ONE_MINUTE;\nexport const INITIAL_BACKOFF_TIME = ONE_SECOND;\nexport function sendWithRetryStrategy(payload, state, sendStrategy, trackType, reportError, requestObservable) {\n    if (state.transportStatus === 0 /* TransportStatus.UP */ &&\n        state.queuedPayloads.size() === 0 &&\n        state.bandwidthMonitor.canHandle(payload)) {\n        send(payload, state, sendStrategy, requestObservable, {\n            onSuccess: () => retryQueuedPayloads(0 /* RetryReason.AFTER_SUCCESS */, state, sendStrategy, trackType, reportError, requestObservable),\n            onFailure: () => {\n                if (!state.queuedPayloads.enqueue(payload)) {\n                    requestObservable.notify({ type: 'queue-full', bandwidth: state.bandwidthMonitor.stats(), payload });\n                }\n                scheduleRetry(state, sendStrategy, trackType, reportError, requestObservable);\n            },\n        });\n    }\n    else {\n        if (!state.queuedPayloads.enqueue(payload)) {\n            requestObservable.notify({ type: 'queue-full', bandwidth: state.bandwidthMonitor.stats(), payload });\n        }\n    }\n}\nfunction scheduleRetry(state, sendStrategy, trackType, reportError, requestObservable) {\n    if (state.transportStatus !== 2 /* TransportStatus.DOWN */) {\n        return;\n    }\n    setTimeout(() => {\n        const payload = state.queuedPayloads.first();\n        send(payload, state, sendStrategy, requestObservable, {\n            onSuccess: () => {\n                state.queuedPayloads.dequeue();\n                state.currentBackoffTime = INITIAL_BACKOFF_TIME;\n                retryQueuedPayloads(1 /* RetryReason.AFTER_RESUME */, state, sendStrategy, trackType, reportError, requestObservable);\n            },\n            onFailure: () => {\n                state.currentBackoffTime = Math.min(MAX_BACKOFF_TIME, state.currentBackoffTime * 2);\n                scheduleRetry(state, sendStrategy, trackType, reportError, requestObservable);\n            },\n        });\n    }, state.currentBackoffTime);\n}\nfunction send(payload, state, sendStrategy, requestObservable, { onSuccess, onFailure }) {\n    state.bandwidthMonitor.add(payload);\n    sendStrategy(payload, (response) => {\n        state.bandwidthMonitor.remove(payload);\n        if (!shouldRetryRequest(response)) {\n            state.transportStatus = 0 /* TransportStatus.UP */;\n            requestObservable.notify({ type: 'success', bandwidth: state.bandwidthMonitor.stats(), payload });\n            onSuccess();\n        }\n        else {\n            // do not consider transport down if another ongoing request could succeed\n            state.transportStatus =\n                state.bandwidthMonitor.ongoingRequestCount > 0 ? 1 /* TransportStatus.FAILURE_DETECTED */ : 2 /* TransportStatus.DOWN */;\n            payload.retry = {\n                count: payload.retry ? payload.retry.count + 1 : 1,\n                lastFailureStatus: response.status,\n            };\n            requestObservable.notify({ type: 'failure', bandwidth: state.bandwidthMonitor.stats(), payload });\n            onFailure();\n        }\n    });\n}\nfunction retryQueuedPayloads(reason, state, sendStrategy, trackType, reportError, requestObservable) {\n    if (reason === 0 /* RetryReason.AFTER_SUCCESS */ && state.queuedPayloads.isFull() && !state.queueFullReported) {\n        reportError({\n            message: `Reached max ${trackType} events size queued for upload: ${MAX_QUEUE_BYTES_COUNT / ONE_MEBI_BYTE}MiB`,\n            source: ErrorSource.AGENT,\n            startClocks: clocksNow(),\n        });\n        state.queueFullReported = true;\n    }\n    const previousQueue = state.queuedPayloads;\n    state.queuedPayloads = newPayloadQueue();\n    while (previousQueue.size() > 0) {\n        sendWithRetryStrategy(previousQueue.dequeue(), state, sendStrategy, trackType, reportError, requestObservable);\n    }\n}\nfunction shouldRetryRequest(response) {\n    return (response.type !== 'opaque' &&\n        ((response.status === 0 && !navigator.onLine) ||\n            response.status === 408 ||\n            response.status === 429 ||\n            isServerError(response.status)));\n}\nexport function newRetryState() {\n    return {\n        transportStatus: 0 /* TransportStatus.UP */,\n        currentBackoffTime: INITIAL_BACKOFF_TIME,\n        bandwidthMonitor: newBandwidthMonitor(),\n        queuedPayloads: newPayloadQueue(),\n        queueFullReported: false,\n    };\n}\nfunction newPayloadQueue() {\n    const queue = [];\n    return {\n        bytesCount: 0,\n        enqueue(payload) {\n            if (this.isFull()) {\n                return false;\n            }\n            queue.push(payload);\n            this.bytesCount += payload.bytesCount;\n            return true;\n        },\n        first() {\n            return queue[0];\n        },\n        dequeue() {\n            const payload = queue.shift();\n            if (payload) {\n                this.bytesCount -= payload.bytesCount;\n            }\n            return payload;\n        },\n        size() {\n            return queue.length;\n        },\n        isFull() {\n            return this.bytesCount >= MAX_QUEUE_BYTES_COUNT;\n        },\n    };\n}\nfunction newBandwidthMonitor() {\n    return {\n        ongoingRequestCount: 0,\n        ongoingByteCount: 0,\n        canHandle(payload) {\n            return (this.ongoingRequestCount === 0 ||\n                (this.ongoingByteCount + payload.bytesCount <= MAX_ONGOING_BYTES_COUNT &&\n                    this.ongoingRequestCount < MAX_ONGOING_REQUESTS));\n        },\n        add(payload) {\n            this.ongoingRequestCount += 1;\n            this.ongoingByteCount += payload.bytesCount;\n        },\n        remove(payload) {\n            this.ongoingRequestCount -= 1;\n            this.ongoingByteCount -= payload.bytesCount;\n        },\n        stats() {\n            return {\n                ongoingByteCount: this.ongoingByteCount,\n                ongoingRequestCount: this.ongoingRequestCount,\n            };\n        },\n    };\n}\n//# sourceMappingURL=sendWithRetryStrategy.js.map","import { monitor, monitorError } from '../tools/monitor';\nimport { isExperimentalFeatureEnabled, ExperimentalFeature } from '../tools/experimentalFeatures';\nimport { Observable } from '../tools/observable';\nimport { ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nimport { newRetryState, sendWithRetryStrategy } from './sendWithRetryStrategy';\n/**\n * beacon payload max queue size implementation is 64kb\n * ensure that we leave room for logs, rum and potential other users\n */\nexport const RECOMMENDED_REQUEST_BYTES_LIMIT = 16 * ONE_KIBI_BYTE;\nexport function createHttpRequest(endpointBuilders, reportError, bytesLimit = RECOMMENDED_REQUEST_BYTES_LIMIT) {\n    const observable = new Observable();\n    const retryState = newRetryState();\n    return {\n        observable,\n        send: (payload) => {\n            for (const endpointBuilder of endpointBuilders) {\n                sendWithRetryStrategy(payload, retryState, (payload, onResponse) => {\n                    if (isExperimentalFeatureEnabled(ExperimentalFeature.AVOID_FETCH_KEEPALIVE)) {\n                        fetchStrategy(endpointBuilder, payload, onResponse);\n                    }\n                    else {\n                        fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse);\n                    }\n                }, endpointBuilder.trackType, reportError, observable);\n            }\n        },\n        /**\n         * Since fetch keepalive behaves like regular fetch on Firefox,\n         * keep using sendBeaconStrategy on exit\n         */\n        sendOnExit: (payload) => {\n            for (const endpointBuilder of endpointBuilders) {\n                sendBeaconStrategy(endpointBuilder, bytesLimit, payload);\n            }\n        },\n    };\n}\nfunction sendBeaconStrategy(endpointBuilder, bytesLimit, payload) {\n    const canUseBeacon = !!navigator.sendBeacon && payload.bytesCount < bytesLimit;\n    if (canUseBeacon) {\n        try {\n            const beaconUrl = endpointBuilder.build('beacon', payload);\n            const isQueued = navigator.sendBeacon(beaconUrl, payload.data);\n            if (isQueued) {\n                return;\n            }\n        }\n        catch (e) {\n            reportBeaconError(e);\n        }\n    }\n    fetchStrategy(endpointBuilder, payload);\n}\nlet hasReportedBeaconError = false;\nfunction reportBeaconError(e) {\n    if (!hasReportedBeaconError) {\n        hasReportedBeaconError = true;\n        monitorError(e);\n    }\n}\nexport function fetchKeepAliveStrategy(endpointBuilder, bytesLimit, payload, onResponse) {\n    const canUseKeepAlive = isKeepAliveSupported() && payload.bytesCount < bytesLimit;\n    if (canUseKeepAlive) {\n        const fetchUrl = endpointBuilder.build('fetch-keepalive', payload);\n        fetch(fetchUrl, { method: 'POST', body: payload.data, keepalive: true, mode: 'cors' })\n            .then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))\n            .catch(monitor(() => fetchStrategy(endpointBuilder, payload, onResponse)));\n    }\n    else {\n        fetchStrategy(endpointBuilder, payload, onResponse);\n    }\n}\nexport function fetchStrategy(endpointBuilder, payload, onResponse) {\n    const fetchUrl = endpointBuilder.build('fetch', payload);\n    fetch(fetchUrl, { method: 'POST', body: payload.data, mode: 'cors' })\n        .then(monitor((response) => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: response.status, type: response.type })))\n        .catch(monitor(() => onResponse === null || onResponse === void 0 ? void 0 : onResponse({ status: 0 })));\n}\nfunction isKeepAliveSupported() {\n    // Request can throw, cf https://developer.mozilla.org/en-US/docs/Web/API/Request/Request#errors\n    try {\n        return window.Request && 'keepalive' in new Request('http://a');\n    }\n    catch (_a) {\n        return false;\n    }\n}\n//# sourceMappingURL=httpRequest.js.map","import { getGlobalObject } from '../tools/globalObject';\nexport function getEventBridge() {\n    const eventBridgeGlobal = getEventBridgeGlobal();\n    if (!eventBridgeGlobal) {\n        return;\n    }\n    return {\n        getCapabilities() {\n            var _a;\n            return JSON.parse(((_a = eventBridgeGlobal.getCapabilities) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal)) || '[]');\n        },\n        getPrivacyLevel() {\n            var _a;\n            return (_a = eventBridgeGlobal.getPrivacyLevel) === null || _a === void 0 ? void 0 : _a.call(eventBridgeGlobal);\n        },\n        getAllowedWebViewHosts() {\n            return JSON.parse(eventBridgeGlobal.getAllowedWebViewHosts());\n        },\n        send(eventType, event, viewId) {\n            const view = viewId ? { id: viewId } : undefined;\n            eventBridgeGlobal.send(JSON.stringify({ eventType, event, view }));\n        },\n    };\n}\nexport function bridgeSupports(capability) {\n    const bridge = getEventBridge();\n    return !!bridge && bridge.getCapabilities().includes(capability);\n}\nexport function canUseEventBridge(currentHost) {\n    var _a;\n    if (currentHost === void 0) { currentHost = (_a = getGlobalObject().location) === null || _a === void 0 ? void 0 : _a.hostname; }\n    const bridge = getEventBridge();\n    return (!!bridge &&\n        bridge\n            .getAllowedWebViewHosts()\n            .some((allowedHost) => currentHost === allowedHost || currentHost.endsWith(`.${allowedHost}`)));\n}\nfunction getEventBridgeGlobal() {\n    return getGlobalObject().DatadogEventBridge;\n}\n//# sourceMappingURL=eventBridge.js.map","import { Observable } from '../tools/observable';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { addEventListeners, addEventListener } from './addEventListener';\nexport const PageExitReason = {\n    HIDDEN: 'visibility_hidden',\n    UNLOADING: 'before_unload',\n    PAGEHIDE: 'page_hide',\n    FROZEN: 'page_frozen',\n};\nexport function createPageMayExitObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopListeners } = addEventListeners(configuration, window, [\"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, \"freeze\" /* DOM_EVENT.FREEZE */], (event) => {\n            if (event.type === \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */ && document.visibilityState === 'hidden') {\n                /**\n                 * Only event that guarantee to fire on mobile devices when the page transitions to background state\n                 * (e.g. when user switches to a different application, goes to homescreen, etc), or is being unloaded.\n                 */\n                observable.notify({ reason: PageExitReason.HIDDEN });\n            }\n            else if (event.type === \"freeze\" /* DOM_EVENT.FREEZE */) {\n                /**\n                 * After transitioning in background a tab can be freezed to preserve resources. (cf: https://developer.chrome.com/blog/page-lifecycle-api)\n                 * Allow to collect events happening between hidden and frozen state.\n                 */\n                observable.notify({ reason: PageExitReason.FROZEN });\n            }\n        }, { capture: true });\n        const stopBeforeUnloadListener = addEventListener(configuration, window, \"beforeunload\" /* DOM_EVENT.BEFORE_UNLOAD */, () => {\n            observable.notify({ reason: PageExitReason.UNLOADING });\n        }).stop;\n        return () => {\n            stopListeners();\n            stopBeforeUnloadListener();\n        };\n    });\n}\nexport function isPageExitReason(reason) {\n    return objectValues(PageExitReason).includes(reason);\n}\n//# sourceMappingURL=pageMayExitObservable.js.map","import { DOCS_TROUBLESHOOTING, MORE_DETAILS, display } from '../tools/display';\nimport { objectValues } from '../tools/utils/polyfills';\nimport { isPageExitReason } from '../browser/pageMayExitObservable';\nimport { jsonStringify } from '../tools/serialisation/jsonStringify';\nimport { computeBytesCount, ONE_KIBI_BYTE } from '../tools/utils/byteUtils';\nexport const MESSAGE_BYTES_LIMIT = 256 * ONE_KIBI_BYTE;\nexport function createBatch({ encoder, request, flushController, }) {\n    let upsertBuffer = {};\n    const flushSubscription = flushController.flushObservable.subscribe((event) => flush(event));\n    function push(serializedMessage, estimatedMessageBytesCount, key) {\n        flushController.notifyBeforeAddMessage(estimatedMessageBytesCount);\n        if (key !== undefined) {\n            upsertBuffer[key] = serializedMessage;\n            flushController.notifyAfterAddMessage();\n        }\n        else {\n            encoder.write(encoder.isEmpty ? serializedMessage : `\\n${serializedMessage}`, (realMessageBytesCount) => {\n                flushController.notifyAfterAddMessage(realMessageBytesCount - estimatedMessageBytesCount);\n            });\n        }\n    }\n    function hasMessageFor(key) {\n        return key !== undefined && upsertBuffer[key] !== undefined;\n    }\n    function remove(key) {\n        const removedMessage = upsertBuffer[key];\n        delete upsertBuffer[key];\n        const messageBytesCount = encoder.estimateEncodedBytesCount(removedMessage);\n        flushController.notifyAfterRemoveMessage(messageBytesCount);\n    }\n    function addOrUpdate(message, key) {\n        const serializedMessage = jsonStringify(message);\n        const estimatedMessageBytesCount = encoder.estimateEncodedBytesCount(serializedMessage);\n        if (estimatedMessageBytesCount >= MESSAGE_BYTES_LIMIT) {\n            display.warn(`Discarded a message whose size was bigger than the maximum allowed size ${MESSAGE_BYTES_LIMIT / ONE_KIBI_BYTE}KiB. ${MORE_DETAILS} ${DOCS_TROUBLESHOOTING}/#technical-limitations`);\n            return;\n        }\n        if (hasMessageFor(key)) {\n            remove(key);\n        }\n        push(serializedMessage, estimatedMessageBytesCount, key);\n    }\n    function flush(event) {\n        const upsertMessages = objectValues(upsertBuffer).join('\\n');\n        upsertBuffer = {};\n        const pageMightExit = isPageExitReason(event.reason);\n        const send = pageMightExit ? request.sendOnExit : request.send;\n        if (pageMightExit &&\n            // Note: checking that the encoder is async is not strictly needed, but it's an optimization:\n            // if the encoder is async we need to send two requests in some cases (one for encoded data\n            // and the other for non-encoded data). But if it's not async, we don't have to worry about\n            // it and always send a single request.\n            encoder.isAsync) {\n            const encoderResult = encoder.finishSync();\n            // Send encoded messages\n            if (encoderResult.outputBytesCount) {\n                send(formatPayloadFromEncoder(encoderResult));\n            }\n            // Send messages that are not yet encoded at this point\n            const pendingMessages = [encoderResult.pendingData, upsertMessages].filter(Boolean).join('\\n');\n            if (pendingMessages) {\n                send({\n                    data: pendingMessages,\n                    bytesCount: computeBytesCount(pendingMessages),\n                });\n            }\n        }\n        else {\n            if (upsertMessages) {\n                encoder.write(encoder.isEmpty ? upsertMessages : `\\n${upsertMessages}`);\n            }\n            encoder.finish((encoderResult) => {\n                send(formatPayloadFromEncoder(encoderResult));\n            });\n        }\n    }\n    return {\n        flushController,\n        add: addOrUpdate,\n        upsert: addOrUpdate,\n        stop: flushSubscription.unsubscribe,\n    };\n}\nfunction formatPayloadFromEncoder(encoderResult) {\n    let data;\n    if (typeof encoderResult.output === 'string') {\n        data = encoderResult.output;\n    }\n    else {\n        data = new Blob([encoderResult.output], {\n            // This will set the 'Content-Type: text/plain' header. Reasoning:\n            // * The intake rejects the request if there is no content type.\n            // * The browser will issue CORS preflight requests if we set it to 'application/json', which\n            // could induce higher intake load (and maybe has other impacts).\n            // * Also it's not quite JSON, since we are concatenating multiple JSON objects separated by\n            // new lines.\n            type: 'text/plain',\n        });\n    }\n    return {\n        data,\n        bytesCount: encoderResult.outputBytesCount,\n        encoding: encoderResult.encoding,\n    };\n}\n//# sourceMappingURL=batch.js.map","import { isWorkerEnvironment } from '../tools/globalObject';\nimport { Observable } from '../tools/observable';\nimport { clearTimeout, setTimeout } from '../tools/timer';\nimport { ONE_SECOND } from '../tools/utils/timeUtils';\nimport { RECOMMENDED_REQUEST_BYTES_LIMIT } from './httpRequest';\n/**\n * flush automatically, aim to be lower than ALB connection timeout\n * to maximize connection reuse.\n */\nexport const FLUSH_DURATION_LIMIT = (30 * ONE_SECOND);\n/**\n * When using the SDK in a Worker Environment, we limit the batch size to 1 to ensure it can be sent\n * in a single event.\n */\nexport const MESSAGES_LIMIT = isWorkerEnvironment ? 1 : 50;\n/**\n * Returns a \"flush controller\", responsible of notifying when flushing a pool of pending data needs\n * to happen. The implementation is designed to support both synchronous and asynchronous usages,\n * but relies on invariants described in each method documentation to keep a coherent state.\n */\nexport function createFlushController({ pageMayExitObservable, sessionExpireObservable }) {\n    const pageMayExitSubscription = pageMayExitObservable.subscribe((event) => flush(event.reason));\n    const sessionExpireSubscription = sessionExpireObservable.subscribe(() => flush('session_expire'));\n    const flushObservable = new Observable(() => () => {\n        pageMayExitSubscription.unsubscribe();\n        sessionExpireSubscription.unsubscribe();\n    });\n    let currentBytesCount = 0;\n    let currentMessagesCount = 0;\n    function flush(flushReason) {\n        if (currentMessagesCount === 0) {\n            return;\n        }\n        const messagesCount = currentMessagesCount;\n        const bytesCount = currentBytesCount;\n        currentMessagesCount = 0;\n        currentBytesCount = 0;\n        cancelDurationLimitTimeout();\n        flushObservable.notify({\n            reason: flushReason,\n            messagesCount,\n            bytesCount,\n        });\n    }\n    let durationLimitTimeoutId;\n    function scheduleDurationLimitTimeout() {\n        if (durationLimitTimeoutId === undefined) {\n            durationLimitTimeoutId = setTimeout(() => {\n                flush('duration_limit');\n            }, FLUSH_DURATION_LIMIT);\n        }\n    }\n    function cancelDurationLimitTimeout() {\n        clearTimeout(durationLimitTimeoutId);\n        durationLimitTimeoutId = undefined;\n    }\n    return {\n        flushObservable,\n        get messagesCount() {\n            return currentMessagesCount;\n        },\n        /**\n         * Notifies that a message will be added to a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right before adding the message, so no flush\n         * event can happen after `notifyBeforeAddMessage` and before adding the message.\n         *\n         * @param estimatedMessageBytesCount - an estimation of the message bytes count once it is\n         * actually added.\n         */\n        notifyBeforeAddMessage(estimatedMessageBytesCount) {\n            if (currentBytesCount + estimatedMessageBytesCount >= RECOMMENDED_REQUEST_BYTES_LIMIT) {\n                flush('bytes_limit');\n            }\n            // Consider the message to be added now rather than in `notifyAfterAddMessage`, because if no\n            // message was added yet and `notifyAfterAddMessage` is called asynchronously, we still want\n            // to notify when a flush is needed (for example on page exit).\n            currentMessagesCount += 1;\n            currentBytesCount += estimatedMessageBytesCount;\n            scheduleDurationLimitTimeout();\n        },\n        /**\n         * Notifies that a message *was* added to a pool of pending messages waiting to be flushed.\n         *\n         * This function can be called asynchronously after the message was added, but in this case it\n         * should not be called if a flush event occurred in between.\n         *\n         * @param messageBytesCountDiff - the difference between the estimated message bytes count and\n         * its actual bytes count once added to the pool.\n         */\n        notifyAfterAddMessage(messageBytesCountDiff = 0) {\n            currentBytesCount += messageBytesCountDiff;\n            if (currentMessagesCount >= MESSAGES_LIMIT) {\n                flush('messages_limit');\n            }\n            else if (currentBytesCount >= RECOMMENDED_REQUEST_BYTES_LIMIT) {\n                flush('bytes_limit');\n            }\n        },\n        /**\n         * Notifies that a message was removed from a pool of pending messages waiting to be flushed.\n         *\n         * This function needs to be called synchronously, right after removing the message, so no flush\n         * event can happen after removing the message and before `notifyAfterRemoveMessage`.\n         *\n         * @param messageBytesCount - the message bytes count that was added to the pool. Should\n         * correspond to the sum of bytes counts passed to `notifyBeforeAddMessage` and\n         * `notifyAfterAddMessage`.\n         */\n        notifyAfterRemoveMessage(messageBytesCount) {\n            currentBytesCount -= messageBytesCount;\n            currentMessagesCount -= 1;\n            if (currentMessagesCount === 0) {\n                cancelDurationLimitTimeout();\n            }\n        },\n    };\n}\n//# sourceMappingURL=flushController.js.map","import { combine } from './mergeInto';\n// Discards the event from being sent\nexport const DISCARDED = 'DISCARDED';\n// Skips from the assembly of the event\nexport const SKIPPED = 'SKIPPED';\nexport function abstractHooks() {\n    const callbacks = {};\n    return {\n        register(hookName, callback) {\n            if (!callbacks[hookName]) {\n                callbacks[hookName] = [];\n            }\n            callbacks[hookName].push(callback);\n            return {\n                unregister: () => {\n                    callbacks[hookName] = callbacks[hookName].filter((cb) => cb !== callback);\n                },\n            };\n        },\n        triggerHook(hookName, param) {\n            const hookCallbacks = callbacks[hookName] || [];\n            const results = [];\n            for (const callback of hookCallbacks) {\n                const result = callback(param);\n                if (result === DISCARDED) {\n                    return DISCARDED;\n                }\n                if (result === SKIPPED) {\n                    continue;\n                }\n                results.push(result);\n            }\n            return combine(...results);\n        },\n    };\n}\n//# sourceMappingURL=abstractHooks.js.map","export const TelemetryType = {\n    LOG: 'log',\n    CONFIGURATION: 'configuration',\n    USAGE: 'usage',\n};\n//# sourceMappingURL=rawTelemetryEvent.types.js.map","import { ConsoleApiName } from '../../tools/display';\nimport { NO_ERROR_STACK_PRESENT_MESSAGE, isError } from '../error/error';\nimport { toStackTraceString } from '../../tools/stackTrace/handlingStack';\nimport { getExperimentalFeatures } from '../../tools/experimentalFeatures';\nimport { buildTags } from '../tags';\nimport { INTAKE_SITE_STAGING, INTAKE_SITE_US1_FED } from '../intakeSites';\nimport { BufferedObservable, Observable } from '../../tools/observable';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nimport { displayIfDebugEnabled, startMonitorErrorCollection } from '../../tools/monitor';\nimport { sendToExtension } from '../../tools/sendToExtension';\nimport { performDraw } from '../../tools/utils/numberUtils';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { combine } from '../../tools/mergeInto';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { getConnectivity } from '../connectivity';\nimport { canUseEventBridge, createFlushController, createHttpRequest, getEventBridge, createBatch, } from '../../transport';\nimport { DISCARDED } from '../../tools/abstractHooks';\nimport { globalObject, isWorkerEnvironment } from '../../tools/globalObject';\nimport { TelemetryType } from './rawTelemetryEvent.types';\nconst ALLOWED_FRAME_URLS = [\n    'https://www.datadoghq-browser-agent.com',\n    'https://www.datad0g-browser-agent.com',\n    'https://d3uc069fcn7uxw.cloudfront.net',\n    'https://d20xtzwzcl0ceb.cloudfront.net',\n    'http://localhost',\n    '<anonymous>',\n];\nconst METRIC_SAMPLE_RATE = 1;\nconst TELEMETRY_EXCLUDED_SITES = [INTAKE_SITE_US1_FED];\nconst MAX_TELEMETRY_EVENTS_PER_PAGE = 15;\nlet telemetryObservable;\nexport function getTelemetryObservable() {\n    if (!telemetryObservable) {\n        telemetryObservable = new BufferedObservable(100);\n    }\n    return telemetryObservable;\n}\nexport function startTelemetry(telemetryService, configuration, hooks, reportError, pageMayExitObservable, createEncoder) {\n    const observable = new Observable();\n    const { stop } = startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, observable);\n    const { enabled, metricsEnabled } = startTelemetryCollection(telemetryService, configuration, hooks, observable);\n    return {\n        stop,\n        enabled,\n        metricsEnabled,\n    };\n}\nexport function startTelemetryCollection(telemetryService, configuration, hooks, observable, metricSampleRate = METRIC_SAMPLE_RATE, maxTelemetryEventsPerPage = MAX_TELEMETRY_EVENTS_PER_PAGE) {\n    const alreadySentEventsByKind = {};\n    const telemetryEnabled = !TELEMETRY_EXCLUDED_SITES.includes(configuration.site) && performDraw(configuration.telemetrySampleRate);\n    const telemetryEnabledPerType = {\n        [TelemetryType.LOG]: telemetryEnabled,\n        [TelemetryType.CONFIGURATION]: telemetryEnabled && performDraw(configuration.telemetryConfigurationSampleRate),\n        [TelemetryType.USAGE]: telemetryEnabled && performDraw(configuration.telemetryUsageSampleRate),\n        // not an actual \"type\" but using a single draw for all metrics\n        metric: telemetryEnabled && performDraw(metricSampleRate),\n    };\n    const runtimeEnvInfo = getRuntimeEnvInfo();\n    const telemetryObservable = getTelemetryObservable();\n    telemetryObservable.subscribe(({ rawEvent, metricName }) => {\n        if ((metricName && !telemetryEnabledPerType['metric']) || !telemetryEnabledPerType[rawEvent.type]) {\n            return;\n        }\n        const kind = metricName || rawEvent.status || rawEvent.type;\n        let alreadySentEvents = alreadySentEventsByKind[kind];\n        if (!alreadySentEvents) {\n            alreadySentEvents = alreadySentEventsByKind[kind] = new Set();\n        }\n        if (alreadySentEvents.size >= maxTelemetryEventsPerPage) {\n            return;\n        }\n        const stringifiedEvent = jsonStringify(rawEvent);\n        if (alreadySentEvents.has(stringifiedEvent)) {\n            return;\n        }\n        const defaultTelemetryEventAttributes = hooks.triggerHook(1 /* HookNames.AssembleTelemetry */, {\n            startTime: clocksNow().relative,\n        });\n        if (defaultTelemetryEventAttributes === DISCARDED) {\n            return;\n        }\n        const event = toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo);\n        observable.notify(event);\n        sendToExtension('telemetry', event);\n        alreadySentEvents.add(stringifiedEvent);\n    });\n    telemetryObservable.unbuffer();\n    startMonitorErrorCollection(addTelemetryError);\n    return {\n        enabled: telemetryEnabled,\n        metricsEnabled: telemetryEnabledPerType['metric'],\n    };\n    function toTelemetryEvent(defaultTelemetryEventAttributes, telemetryService, rawEvent, runtimeEnvInfo) {\n        const clockNow = clocksNow();\n        const event = {\n            type: 'telemetry',\n            date: clockNow.timeStamp,\n            service: telemetryService,\n            version: \"6.24.1\",\n            source: 'browser',\n            _dd: {\n                format_version: 2,\n            },\n            telemetry: combine(rawEvent, {\n                runtime_env: runtimeEnvInfo,\n                connectivity: getConnectivity(),\n                sdk_setup: \"npm\",\n            }),\n            ddtags: buildTags(configuration).join(','),\n            experimental_features: Array.from(getExperimentalFeatures()),\n        };\n        return combine(event, defaultTelemetryEventAttributes);\n    }\n}\nfunction startTelemetryTransport(configuration, reportError, pageMayExitObservable, createEncoder, telemetryObservable) {\n    const cleanupTasks = [];\n    if (canUseEventBridge()) {\n        const bridge = getEventBridge();\n        const telemetrySubscription = telemetryObservable.subscribe((event) => bridge.send('internal_telemetry', event));\n        cleanupTasks.push(telemetrySubscription.unsubscribe);\n    }\n    else {\n        const endpoints = [configuration.rumEndpointBuilder];\n        if (configuration.replica && isTelemetryReplicationAllowed(configuration)) {\n            endpoints.push(configuration.replica.rumEndpointBuilder);\n        }\n        const telemetryBatch = createBatch({\n            encoder: createEncoder(4 /* DeflateEncoderStreamId.TELEMETRY */),\n            request: createHttpRequest(endpoints, reportError),\n            flushController: createFlushController({\n                pageMayExitObservable,\n                // We don't use an actual session expire observable here, to make telemetry collection\n                // independent of the session. This allows to start and send telemetry events earlier.\n                sessionExpireObservable: new Observable(),\n            }),\n        });\n        cleanupTasks.push(telemetryBatch.stop);\n        const telemetrySubscription = telemetryObservable.subscribe(telemetryBatch.add);\n        cleanupTasks.push(telemetrySubscription.unsubscribe);\n    }\n    return {\n        stop: () => cleanupTasks.forEach((task) => task()),\n    };\n}\nfunction getRuntimeEnvInfo() {\n    var _a;\n    return {\n        is_local_file: ((_a = globalObject.location) === null || _a === void 0 ? void 0 : _a.protocol) === 'file:',\n        is_worker: isWorkerEnvironment,\n    };\n}\nexport function resetTelemetry() {\n    telemetryObservable = undefined;\n}\n/**\n * Avoid mixing telemetry events from different data centers\n * but keep replicating staging events for reliability\n */\nfunction isTelemetryReplicationAllowed(configuration) {\n    return configuration.site === INTAKE_SITE_STAGING;\n}\nexport function addTelemetryDebug(message, context) {\n    displayIfDebugEnabled(ConsoleApiName.debug, message, context);\n    getTelemetryObservable().notify({\n        rawEvent: {\n            type: TelemetryType.LOG,\n            message,\n            status: \"debug\" /* StatusType.debug */,\n            ...context,\n        },\n    });\n}\nexport function addTelemetryError(e, context) {\n    getTelemetryObservable().notify({\n        rawEvent: {\n            type: TelemetryType.LOG,\n            status: \"error\" /* StatusType.error */,\n            ...formatError(e),\n            ...context,\n        },\n    });\n}\nexport function addTelemetryConfiguration(configuration) {\n    getTelemetryObservable().notify({\n        rawEvent: {\n            type: TelemetryType.CONFIGURATION,\n            configuration,\n        },\n    });\n}\nexport function addTelemetryMetrics(metricName, context) {\n    getTelemetryObservable().notify({\n        rawEvent: {\n            type: TelemetryType.LOG,\n            message: metricName,\n            status: \"debug\" /* StatusType.debug */,\n            ...context,\n        },\n        metricName,\n    });\n}\nexport function addTelemetryUsage(usage) {\n    getTelemetryObservable().notify({\n        rawEvent: {\n            type: TelemetryType.USAGE,\n            usage,\n        },\n    });\n}\nexport function formatError(e) {\n    if (isError(e)) {\n        const stackTrace = computeStackTrace(e);\n        return {\n            error: {\n                kind: stackTrace.name,\n                stack: toStackTraceString(scrubCustomerFrames(stackTrace)),\n            },\n            message: stackTrace.message,\n        };\n    }\n    return {\n        error: {\n            stack: NO_ERROR_STACK_PRESENT_MESSAGE,\n        },\n        message: `${\"Uncaught\" /* NonErrorPrefix.UNCAUGHT */} ${jsonStringify(e)}`,\n    };\n}\nexport function scrubCustomerFrames(stackTrace) {\n    stackTrace.stack = stackTrace.stack.filter((frame) => !frame.url || ALLOWED_FRAME_URLS.some((allowedFrameUrl) => frame.url.startsWith(allowedFrameUrl)));\n    return stackTrace;\n}\n//# sourceMappingURL=telemetry.js.map","export function removeDuplicates(array) {\n    const set = new Set();\n    array.forEach((item) => set.add(item));\n    return Array.from(set);\n}\nexport function removeItem(array, item) {\n    const index = array.indexOf(item);\n    if (index >= 0) {\n        array.splice(index, 1);\n    }\n}\nexport function isNonEmptyArray(value) {\n    return Array.isArray(value) && value.length > 0;\n}\n//# sourceMappingURL=arrayUtils.js.map","import { setInterval, clearInterval } from './timer';\nimport { removeItem } from './utils/arrayUtils';\nimport { addDuration, relativeNow, ONE_MINUTE } from './utils/timeUtils';\nconst END_OF_TIMES = Infinity;\nexport const CLEAR_OLD_VALUES_INTERVAL = ONE_MINUTE;\nlet cleanupHistoriesInterval = null;\nconst cleanupTasks = new Set();\nfunction cleanupHistories() {\n    cleanupTasks.forEach((task) => task());\n}\nexport function createValueHistory({ expireDelay, maxEntries, }) {\n    let entries = [];\n    if (!cleanupHistoriesInterval) {\n        cleanupHistoriesInterval = setInterval(() => cleanupHistories(), CLEAR_OLD_VALUES_INTERVAL);\n    }\n    const clearExpiredValues = () => {\n        const oldTimeThreshold = relativeNow() - expireDelay;\n        while (entries.length > 0 && entries[entries.length - 1].endTime < oldTimeThreshold) {\n            entries.pop();\n        }\n    };\n    cleanupTasks.add(clearExpiredValues);\n    /**\n     * Add a value to the history associated with a start time. Returns a reference to this newly\n     * added entry that can be removed or closed.\n     */\n    function add(value, startTime) {\n        const entry = {\n            value,\n            startTime,\n            endTime: END_OF_TIMES,\n            remove: () => {\n                removeItem(entries, entry);\n            },\n            close: (endTime) => {\n                entry.endTime = endTime;\n            },\n        };\n        if (maxEntries && entries.length >= maxEntries) {\n            entries.pop();\n        }\n        entries.unshift(entry);\n        return entry;\n    }\n    /**\n     * Return the latest value that was active during `startTime`, or the currently active value\n     * if no `startTime` is provided. This method assumes that entries are not overlapping.\n     *\n     * If `option.returnInactive` is true, returns the value at `startTime` (active or not).\n     */\n    function find(startTime = END_OF_TIMES, options = { returnInactive: false }) {\n        for (const entry of entries) {\n            if (entry.startTime <= startTime) {\n                if (options.returnInactive || startTime <= entry.endTime) {\n                    return entry.value;\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * Helper function to close the currently active value, if any. This method assumes that entries\n     * are not overlapping.\n     */\n    function closeActive(endTime) {\n        const latestEntry = entries[0];\n        if (latestEntry && latestEntry.endTime === END_OF_TIMES) {\n            latestEntry.close(endTime);\n        }\n    }\n    /**\n     * Return all values with an active period overlapping with the duration,\n     * or all values that were active during `startTime` if no duration is provided,\n     * or all currently active values if no `startTime` is provided.\n     */\n    function findAll(startTime = END_OF_TIMES, duration = 0) {\n        const endTime = addDuration(startTime, duration);\n        return entries\n            .filter((entry) => entry.startTime <= endTime && startTime <= entry.endTime)\n            .map((entry) => entry.value);\n    }\n    /**\n     * Remove all entries from this collection.\n     */\n    function reset() {\n        entries = [];\n    }\n    /**\n     * Stop internal garbage collection of past entries.\n     */\n    function stop() {\n        cleanupTasks.delete(clearExpiredValues);\n        if (cleanupTasks.size === 0 && cleanupHistoriesInterval) {\n            clearInterval(cleanupHistoriesInterval);\n            cleanupHistoriesInterval = null;\n        }\n    }\n    return { add, find, closeActive, findAll, reset, stop };\n}\n//# sourceMappingURL=valueHistory.js.map","import { getInitCookie } from '../../browser/cookie';\nimport { globalObject, isWorkerEnvironment } from '../../tools/globalObject';\nexport const SYNTHETICS_TEST_ID_COOKIE_NAME = 'datadog-synthetics-public-id';\nexport const SYNTHETICS_RESULT_ID_COOKIE_NAME = 'datadog-synthetics-result-id';\nexport const SYNTHETICS_INJECTS_RUM_COOKIE_NAME = 'datadog-synthetics-injects-rum';\nexport function willSyntheticsInjectRum() {\n    if (isWorkerEnvironment) {\n        // We don't expect to run synthetics tests in a worker environment\n        return false;\n    }\n    return Boolean(globalObject._DATADOG_SYNTHETICS_INJECTS_RUM || getInitCookie(SYNTHETICS_INJECTS_RUM_COOKIE_NAME));\n}\nexport function getSyntheticsTestId() {\n    const value = window._DATADOG_SYNTHETICS_PUBLIC_ID || getInitCookie(SYNTHETICS_TEST_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\nexport function getSyntheticsResultId() {\n    const value = window._DATADOG_SYNTHETICS_RESULT_ID || getInitCookie(SYNTHETICS_RESULT_ID_COOKIE_NAME);\n    return typeof value === 'string' ? value : undefined;\n}\nexport function isSyntheticsTest() {\n    return Boolean(getSyntheticsTestId() && getSyntheticsResultId());\n}\n//# sourceMappingURL=syntheticsWorkerValues.js.map","import { Observable } from '../../tools/observable';\nimport { createValueHistory } from '../../tools/valueHistory';\nimport { clocksOrigin, dateNow, ONE_MINUTE, relativeNow } from '../../tools/utils/timeUtils';\nimport { addEventListener, addEventListeners } from '../../browser/addEventListener';\nimport { clearInterval, setInterval } from '../../tools/timer';\nimport { addTelemetryDebug } from '../telemetry';\nimport { isSyntheticsTest } from '../synthetics/syntheticsWorkerValues';\nimport { getCurrentSite } from '../../browser/cookie';\nimport { ExperimentalFeature, isExperimentalFeatureEnabled } from '../../tools/experimentalFeatures';\nimport { findLast } from '../../tools/utils/polyfills';\nimport { monitorError } from '../../tools/monitor';\nimport { SESSION_NOT_TRACKED, SESSION_TIME_OUT_DELAY, SessionPersistence } from './sessionConstants';\nimport { startSessionStore } from './sessionStore';\nimport { toSessionState } from './sessionState';\nimport { retrieveSessionCookie } from './storeStrategies/sessionInCookie';\nimport { SESSION_STORE_KEY } from './storeStrategies/sessionStoreStrategy';\nimport { retrieveSessionFromLocalStorage } from './storeStrategies/sessionInLocalStorage';\nexport const VISIBILITY_CHECK_DELAY = ONE_MINUTE;\nconst SESSION_CONTEXT_TIMEOUT_DELAY = SESSION_TIME_OUT_DELAY;\nlet stopCallbacks = [];\nexport function startSessionManager(configuration, productKey, computeTrackingType, trackingConsentState) {\n    const renewObservable = new Observable();\n    const expireObservable = new Observable();\n    // TODO - Improve configuration type and remove assertion\n    const sessionStore = startSessionStore(configuration.sessionStoreStrategyType, configuration, productKey, computeTrackingType);\n    stopCallbacks.push(() => sessionStore.stop());\n    const sessionContextHistory = createValueHistory({\n        expireDelay: SESSION_CONTEXT_TIMEOUT_DELAY,\n    });\n    stopCallbacks.push(() => sessionContextHistory.stop());\n    sessionStore.renewObservable.subscribe(() => {\n        sessionContextHistory.add(buildSessionContext(), relativeNow());\n        renewObservable.notify();\n    });\n    sessionStore.expireObservable.subscribe(() => {\n        expireObservable.notify();\n        sessionContextHistory.closeActive(relativeNow());\n    });\n    // We expand/renew session unconditionally as tracking consent is always granted when the session\n    // manager is started.\n    sessionStore.expandOrRenewSession();\n    sessionContextHistory.add(buildSessionContext(), clocksOrigin().relative);\n    if (isExperimentalFeatureEnabled(ExperimentalFeature.SHORT_SESSION_INVESTIGATION)) {\n        const session = sessionStore.getSession();\n        if (session) {\n            detectSessionIdChange(configuration, session);\n        }\n    }\n    trackingConsentState.observable.subscribe(() => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n        else {\n            sessionStore.expire(false);\n        }\n    });\n    trackActivity(configuration, () => {\n        if (trackingConsentState.isGranted()) {\n            sessionStore.expandOrRenewSession();\n        }\n    });\n    trackVisibility(configuration, () => sessionStore.expandSession());\n    trackResume(configuration, () => sessionStore.restartSession());\n    function buildSessionContext() {\n        const session = sessionStore.getSession();\n        if (!session) {\n            reportUnexpectedSessionState(configuration).catch(() => void 0); // Ignore errors\n            return {\n                id: 'invalid',\n                trackingType: SESSION_NOT_TRACKED,\n                isReplayForced: false,\n                anonymousId: undefined,\n            };\n        }\n        return {\n            id: session.id,\n            trackingType: session[productKey],\n            isReplayForced: !!session.forcedReplay,\n            anonymousId: session.anonymousId,\n        };\n    }\n    return {\n        findSession: (startTime, options) => sessionContextHistory.find(startTime, options),\n        renewObservable,\n        expireObservable,\n        sessionStateUpdateObservable: sessionStore.sessionStateUpdateObservable,\n        expire: sessionStore.expire,\n        updateSessionState: sessionStore.updateSessionState,\n    };\n}\nexport function stopSessionManager() {\n    stopCallbacks.forEach((e) => e());\n    stopCallbacks = [];\n}\nfunction trackActivity(configuration, expandOrRenewSession) {\n    const { stop } = addEventListeners(configuration, window, [\"click\" /* DOM_EVENT.CLICK */, \"touchstart\" /* DOM_EVENT.TOUCH_START */, \"keydown\" /* DOM_EVENT.KEY_DOWN */, \"scroll\" /* DOM_EVENT.SCROLL */], expandOrRenewSession, { capture: true, passive: true });\n    stopCallbacks.push(stop);\n}\nfunction trackVisibility(configuration, expandSession) {\n    const expandSessionWhenVisible = () => {\n        if (document.visibilityState === 'visible') {\n            expandSession();\n        }\n    };\n    const { stop } = addEventListener(configuration, document, \"visibilitychange\" /* DOM_EVENT.VISIBILITY_CHANGE */, expandSessionWhenVisible);\n    stopCallbacks.push(stop);\n    const visibilityCheckInterval = setInterval(expandSessionWhenVisible, VISIBILITY_CHECK_DELAY);\n    stopCallbacks.push(() => {\n        clearInterval(visibilityCheckInterval);\n    });\n}\nfunction trackResume(configuration, cb) {\n    const { stop } = addEventListener(configuration, window, \"resume\" /* DOM_EVENT.RESUME */, cb, { capture: true });\n    stopCallbacks.push(stop);\n}\nasync function reportUnexpectedSessionState(configuration) {\n    const sessionStoreStrategyType = configuration.sessionStoreStrategyType;\n    if (!sessionStoreStrategyType) {\n        return;\n    }\n    let rawSession;\n    let cookieContext;\n    if (sessionStoreStrategyType.type === SessionPersistence.COOKIE) {\n        rawSession = retrieveSessionCookie(sessionStoreStrategyType.cookieOptions, configuration);\n        cookieContext = {\n            cookie: await getSessionCookies(),\n            currentDomain: `${window.location.protocol}//${window.location.hostname}`,\n        };\n    }\n    else {\n        rawSession = retrieveSessionFromLocalStorage();\n    }\n    // monitor-until: forever, could be handy to troubleshoot issues until session manager rework\n    addTelemetryDebug('Unexpected session state', {\n        sessionStoreStrategyType: sessionStoreStrategyType.type,\n        session: rawSession,\n        isSyntheticsTest: isSyntheticsTest(),\n        createdTimestamp: rawSession === null || rawSession === void 0 ? void 0 : rawSession.created,\n        expireTimestamp: rawSession === null || rawSession === void 0 ? void 0 : rawSession.expire,\n        ...cookieContext,\n    });\n}\nfunction detectSessionIdChange(configuration, initialSessionState) {\n    if (!window.cookieStore || !initialSessionState.created) {\n        return;\n    }\n    const sessionCreatedTime = Number(initialSessionState.created);\n    const sdkInitTime = dateNow();\n    const { stop } = addEventListener(configuration, cookieStore, \"change\" /* DOM_EVENT.CHANGE */, listener);\n    stopCallbacks.push(stop);\n    function listener(event) {\n        const changed = findLast(event.changed, (change) => change.name === SESSION_STORE_KEY);\n        if (!changed) {\n            return;\n        }\n        const sessionAge = dateNow() - sessionCreatedTime;\n        if (sessionAge > 14 * ONE_MINUTE) {\n            // The session might have expired just because it's too old or lack activity\n            stop();\n        }\n        else {\n            const newSessionState = toSessionState(changed.value);\n            if (newSessionState.id && newSessionState.id !== initialSessionState.id) {\n                stop();\n                const time = dateNow() - sdkInitTime;\n                getSessionCookies()\n                    .then((cookie) => {\n                    // monitor-until: 2025-12-01, after RUM-10845 investigation done\n                    addTelemetryDebug('Session cookie changed', {\n                        time,\n                        session_age: sessionAge,\n                        old: initialSessionState,\n                        new: newSessionState,\n                        cookie,\n                    });\n                })\n                    .catch(monitorError);\n            }\n        }\n    }\n}\nasync function getSessionCookies() {\n    let sessionCookies;\n    if ('cookieStore' in window) {\n        sessionCookies = await window.cookieStore.getAll(SESSION_STORE_KEY);\n    }\n    else {\n        sessionCookies = document.cookie.split(/\\s*;\\s*/).filter((cookie) => cookie.startsWith(SESSION_STORE_KEY));\n    }\n    return {\n        count: sessionCookies.length,\n        domain: getCurrentSite() || 'undefined',\n        ...sessionCookies,\n    };\n}\n//# sourceMappingURL=sessionManager.js.map","import { computeBytesCount } from './utils/byteUtils';\nexport function createIdentityEncoder() {\n    let output = '';\n    let outputBytesCount = 0;\n    return {\n        isAsync: false,\n        get isEmpty() {\n            return !output;\n        },\n        write(data, callback) {\n            const additionalEncodedBytesCount = computeBytesCount(data);\n            outputBytesCount += additionalEncodedBytesCount;\n            output += data;\n            if (callback) {\n                callback(additionalEncodedBytesCount);\n            }\n        },\n        finish(callback) {\n            callback(this.finishSync());\n        },\n        finishSync() {\n            const result = {\n                output,\n                outputBytesCount,\n                rawBytesCount: outputBytesCount,\n                pendingData: '',\n            };\n            output = '';\n            outputBytesCount = 0;\n            return result;\n        },\n        estimateEncodedBytesCount(data) {\n            return data.length;\n        },\n    };\n}\n//# sourceMappingURL=encoder.js.map","// eslint-disable-next-line no-restricted-syntax\nexport class AbstractLifeCycle {\n    constructor() {\n        this.callbacks = {};\n    }\n    notify(eventType, data) {\n        const eventCallbacks = this.callbacks[eventType];\n        if (eventCallbacks) {\n            eventCallbacks.forEach((callback) => callback(data));\n        }\n    }\n    subscribe(eventType, callback) {\n        if (!this.callbacks[eventType]) {\n            this.callbacks[eventType] = [];\n        }\n        this.callbacks[eventType].push(callback);\n        return {\n            unsubscribe: () => {\n                this.callbacks[eventType] = this.callbacks[eventType].filter((other) => callback !== other);\n            },\n        };\n    }\n}\n//# sourceMappingURL=abstractLifeCycle.js.map","import { setTimeout } from '../../tools/timer';\nimport { clocksNow, ONE_MINUTE } from '../../tools/utils/timeUtils';\nimport { ErrorSource } from '../error/error.types';\n// Limit the maximum number of actions, errors and logs per minutes\nconst EVENT_RATE_LIMIT = 3000;\nexport function createEventRateLimiter(eventType, onLimitReached, limit = EVENT_RATE_LIMIT) {\n    let eventCount = 0;\n    let allowNextEvent = false;\n    return {\n        isLimitReached() {\n            if (eventCount === 0) {\n                setTimeout(() => {\n                    eventCount = 0;\n                }, ONE_MINUTE);\n            }\n            eventCount += 1;\n            if (eventCount <= limit || allowNextEvent) {\n                allowNextEvent = false;\n                return false;\n            }\n            if (eventCount === limit + 1) {\n                allowNextEvent = true;\n                try {\n                    onLimitReached({\n                        message: `Reached max number of ${eventType}s by minute: ${limit}`,\n                        source: ErrorSource.AGENT,\n                        startClocks: clocksNow(),\n                    });\n                }\n                finally {\n                    allowNextEvent = false;\n                }\n            }\n            return true;\n        },\n    };\n}\n//# sourceMappingURL=createEventRateLimiter.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { Observable } from '../tools/observable';\nimport { elapsed, clocksNow, timeStampNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nimport { shallowClone } from '../tools/utils/objectUtils';\nimport { addEventListener } from './addEventListener';\nlet xhrObservable;\nconst xhrContexts = new WeakMap();\nexport function initXhrObservable(configuration) {\n    if (!xhrObservable) {\n        xhrObservable = createXhrObservable(configuration);\n    }\n    return xhrObservable;\n}\nfunction createXhrObservable(configuration) {\n    return new Observable((observable) => {\n        const { stop: stopInstrumentingStart } = instrumentMethod(XMLHttpRequest.prototype, 'open', openXhr);\n        const { stop: stopInstrumentingSend } = instrumentMethod(XMLHttpRequest.prototype, 'send', (call) => {\n            sendXhr(call, configuration, observable);\n        }, { computeHandlingStack: true });\n        const { stop: stopInstrumentingAbort } = instrumentMethod(XMLHttpRequest.prototype, 'abort', abortXhr);\n        return () => {\n            stopInstrumentingStart();\n            stopInstrumentingSend();\n            stopInstrumentingAbort();\n        };\n    });\n}\nfunction openXhr({ target: xhr, parameters: [method, url] }) {\n    xhrContexts.set(xhr, {\n        state: 'open',\n        method: String(method).toUpperCase(),\n        url: normalizeUrl(String(url)),\n    });\n}\nfunction sendXhr({ target: xhr, parameters: [body], handlingStack }, configuration, observable) {\n    const context = xhrContexts.get(xhr);\n    if (!context) {\n        return;\n    }\n    const startContext = context;\n    startContext.state = 'start';\n    startContext.startClocks = clocksNow();\n    startContext.isAborted = false;\n    startContext.xhr = xhr;\n    startContext.handlingStack = handlingStack;\n    startContext.requestBody = body;\n    let hasBeenReported = false;\n    const { stop: stopInstrumentingOnReadyStateChange } = instrumentMethod(xhr, 'onreadystatechange', () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n            // Try to report the XHR as soon as possible, because the XHR may be mutated by the\n            // application during a future event. For example, Angular is calling .abort() on\n            // completed requests during an onreadystatechange event, so the status becomes '0'\n            // before the request is collected.\n            onEnd();\n        }\n    });\n    const onEnd = () => {\n        unsubscribeLoadEndListener();\n        stopInstrumentingOnReadyStateChange();\n        if (hasBeenReported) {\n            return;\n        }\n        hasBeenReported = true;\n        const completeContext = context;\n        completeContext.state = 'complete';\n        completeContext.duration = elapsed(startContext.startClocks.timeStamp, timeStampNow());\n        completeContext.status = xhr.status;\n        if (typeof xhr.response === 'string') {\n            completeContext.responseBody = xhr.response;\n        }\n        observable.notify(shallowClone(completeContext));\n    };\n    const { stop: unsubscribeLoadEndListener } = addEventListener(configuration, xhr, 'loadend', onEnd);\n    observable.notify(startContext);\n}\nfunction abortXhr({ target: xhr }) {\n    const context = xhrContexts.get(xhr);\n    if (context) {\n        context.isAborted = true;\n    }\n}\n//# sourceMappingURL=xhrObservable.js.map","import { concatBuffers } from './utils/byteUtils';\nimport { noop } from './utils/functionUtils';\n/**\n * Read bytes from a ReadableStream until the end of the stream.\n * Returns the bytes if collectStreamBody is true, otherwise returns undefined.\n */\nexport async function readBytesFromStream(stream, options) {\n    const reader = stream.getReader();\n    const chunks = [];\n    while (true) {\n        const result = await reader.read();\n        if (result.done) {\n            break;\n        }\n        if (options.collectStreamBody) {\n            chunks.push(result.value);\n        }\n    }\n    reader.cancel().catch(\n    // we don't care if cancel fails, but we still need to catch the error to avoid reporting it\n    // as an unhandled rejection\n    noop);\n    return options.collectStreamBody ? concatBuffers(chunks) : undefined;\n}\n//# sourceMappingURL=readBytesFromStream.js.map","import { instrumentMethod } from '../tools/instrumentMethod';\nimport { monitorError } from '../tools/monitor';\nimport { Observable } from '../tools/observable';\nimport { clocksNow } from '../tools/utils/timeUtils';\nimport { normalizeUrl } from '../tools/utils/urlPolyfill';\nimport { globalObject } from '../tools/globalObject';\nimport { readBytesFromStream } from '../tools/readBytesFromStream';\nimport { tryToClone } from '../tools/utils/responseUtils';\nlet fetchObservable;\nconst responseBodyActionGetters = [];\nexport function initFetchObservable({ responseBodyAction } = {}) {\n    if (responseBodyAction) {\n        responseBodyActionGetters.push(responseBodyAction);\n    }\n    if (!fetchObservable) {\n        fetchObservable = createFetchObservable();\n    }\n    return fetchObservable;\n}\nexport function resetFetchObservable() {\n    fetchObservable = undefined;\n    responseBodyActionGetters.length = 0;\n}\nfunction createFetchObservable() {\n    return new Observable((observable) => {\n        if (!globalObject.fetch) {\n            return;\n        }\n        const { stop } = instrumentMethod(globalObject, 'fetch', (call) => beforeSend(call, observable), {\n            computeHandlingStack: true,\n        });\n        return stop;\n    });\n}\nfunction beforeSend({ parameters, onPostCall, handlingStack }, observable) {\n    const [input, init] = parameters;\n    let methodFromParams = init && init.method;\n    if (methodFromParams === undefined && input instanceof Request) {\n        methodFromParams = input.method;\n    }\n    const method = methodFromParams !== undefined ? String(methodFromParams).toUpperCase() : 'GET';\n    const url = input instanceof Request ? input.url : normalizeUrl(String(input));\n    const startClocks = clocksNow();\n    const context = {\n        state: 'start',\n        init,\n        input,\n        method,\n        startClocks,\n        url,\n        handlingStack,\n    };\n    observable.notify(context);\n    // Those properties can be changed by observable subscribers\n    parameters[0] = context.input;\n    parameters[1] = context.init;\n    onPostCall((responsePromise) => {\n        afterSend(observable, responsePromise, context).catch(monitorError);\n    });\n}\nasync function afterSend(observable, responsePromise, startContext) {\n    var _a, _b;\n    const context = startContext;\n    context.state = 'resolve';\n    let response;\n    try {\n        response = await responsePromise;\n    }\n    catch (error) {\n        context.status = 0;\n        context.isAborted =\n            ((_b = (_a = context.init) === null || _a === void 0 ? void 0 : _a.signal) === null || _b === void 0 ? void 0 : _b.aborted) || (error instanceof DOMException && error.code === DOMException.ABORT_ERR);\n        context.error = error;\n        observable.notify(context);\n        return;\n    }\n    context.response = response;\n    context.status = response.status;\n    context.responseType = response.type;\n    context.isAborted = false;\n    const responseBodyCondition = responseBodyActionGetters.reduce((action, getter) => Math.max(action, getter(context)), 0 /* ResponseBodyAction.IGNORE */);\n    if (responseBodyCondition !== 0 /* ResponseBodyAction.IGNORE */) {\n        const clonedResponse = tryToClone(response);\n        if (clonedResponse && clonedResponse.body) {\n            try {\n                const bytes = await readBytesFromStream(clonedResponse.body, {\n                    collectStreamBody: responseBodyCondition === 2 /* ResponseBodyAction.COLLECT */,\n                });\n                context.responseBody = bytes && new TextDecoder().decode(bytes);\n            }\n            catch (_c) {\n                // Ignore errors when reading the response body (e.g., stream aborted, network errors)\n                // This is not critical and should not be reported as an SDK error\n            }\n        }\n    }\n    observable.notify(context);\n}\n//# sourceMappingURL=fetchObservable.js.map","import { isError, computeRawError } from '../error/error';\nimport { mergeObservables, Observable } from '../../tools/observable';\nimport { ConsoleApiName, globalConsole } from '../../tools/display';\nimport { callMonitored } from '../../tools/monitor';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { jsonStringify } from '../../tools/serialisation/jsonStringify';\nimport { ErrorSource } from '../error/error.types';\nimport { computeStackTrace } from '../../tools/stackTrace/computeStackTrace';\nimport { createHandlingStack, formatErrorMessage } from '../../tools/stackTrace/handlingStack';\nimport { clocksNow } from '../../tools/utils/timeUtils';\nlet consoleObservablesByApi = {};\nexport function initConsoleObservable(apis) {\n    const consoleObservables = apis.map((api) => {\n        if (!consoleObservablesByApi[api]) {\n            consoleObservablesByApi[api] = createConsoleObservable(api); // we are sure that the observable created for this api will yield the expected ConsoleLog type\n        }\n        return consoleObservablesByApi[api];\n    });\n    return mergeObservables(...consoleObservables);\n}\nexport function resetConsoleObservable() {\n    consoleObservablesByApi = {};\n}\nfunction createConsoleObservable(api) {\n    return new Observable((observable) => {\n        const originalConsoleApi = globalConsole[api];\n        globalConsole[api] = (...params) => {\n            originalConsoleApi.apply(console, params);\n            const handlingStack = createHandlingStack('console error');\n            callMonitored(() => {\n                observable.notify(buildConsoleLog(params, api, handlingStack));\n            });\n        };\n        return () => {\n            globalConsole[api] = originalConsoleApi;\n        };\n    });\n}\nfunction buildConsoleLog(params, api, handlingStack) {\n    const message = params.map((param) => formatConsoleParameters(param)).join(' ');\n    if (api === ConsoleApiName.error) {\n        const firstErrorParam = params.find(isError);\n        const rawError = computeRawError({\n            originalError: firstErrorParam,\n            handlingStack,\n            startClocks: clocksNow(),\n            source: ErrorSource.CONSOLE,\n            handling: \"handled\" /* ErrorHandling.HANDLED */,\n            nonErrorPrefix: \"Provided\" /* NonErrorPrefix.PROVIDED */,\n            // if no good stack is computed from the error, let's not use the fallback stack message\n            // advising the user to use an instance of Error, as console.error is commonly used without an\n            // Error instance.\n            useFallbackStack: false,\n        });\n        // Use the full log message as the error message instead of just the error instance message.\n        rawError.message = message;\n        return {\n            api,\n            message,\n            handlingStack,\n            error: rawError,\n        };\n    }\n    return {\n        api,\n        message,\n        error: undefined,\n        handlingStack,\n    };\n}\nfunction formatConsoleParameters(param) {\n    if (typeof param === 'string') {\n        return sanitize(param);\n    }\n    if (isError(param)) {\n        return formatErrorMessage(computeStackTrace(param));\n    }\n    return jsonStringify(sanitize(param), undefined, 2);\n}\n//# sourceMappingURL=consoleObservable.js.map","import { removeItem } from './utils/arrayUtils';\nconst BUFFER_LIMIT = 500;\n/**\n * createBoundedBuffer creates a BoundedBuffer.\n *\n * @deprecated Use `BufferedObservable` instead.\n */\nexport function createBoundedBuffer() {\n    const buffer = [];\n    const add = (callback) => {\n        const length = buffer.push(callback);\n        if (length > BUFFER_LIMIT) {\n            buffer.splice(0, 1);\n        }\n    };\n    const remove = (callback) => {\n        removeItem(buffer, callback);\n    };\n    const drain = (arg) => {\n        buffer.forEach((callback) => callback(arg));\n        buffer.length = 0;\n    };\n    return {\n        add,\n        remove,\n        drain,\n    };\n}\n//# sourceMappingURL=boundedBuffer.js.map","import { display } from '../../tools/display';\nimport { getType } from '../../tools/utils/typeUtils';\n/**\n * Simple check to ensure an object is a valid context\n */\nexport function checkContext(maybeContext) {\n    const isValid = getType(maybeContext) === 'object';\n    if (!isValid) {\n        display.error('Unsupported context:', maybeContext);\n    }\n    return isValid;\n}\n//# sourceMappingURL=contextUtils.js.map","import { deepClone } from '../../tools/mergeInto';\nimport { sanitize } from '../../tools/serialisation/sanitize';\nimport { Observable } from '../../tools/observable';\nimport { display } from '../../tools/display';\nimport { checkContext } from './contextUtils';\nfunction ensureProperties(context, propertiesConfig, name) {\n    const newContext = { ...context };\n    for (const [key, { required, type }] of Object.entries(propertiesConfig)) {\n        /**\n         * Ensure specified properties are strings as defined here:\n         * https://docs.datadoghq.com/logs/log_configuration/attributes_naming_convention/#user-related-attributes\n         */\n        if (type === 'string' && !isDefined(newContext[key])) {\n            /* eslint-disable @typescript-eslint/no-base-to-string */\n            newContext[key] = String(newContext[key]);\n        }\n        if (required && isDefined(newContext[key])) {\n            display.warn(`The property ${key} of ${name} is required; context will not be sent to the intake.`);\n        }\n    }\n    return newContext;\n}\nfunction isDefined(value) {\n    return value === undefined || value === null || value === '';\n}\nexport function createContextManager(name = '', { propertiesConfig = {}, } = {}) {\n    let context = {};\n    const changeObservable = new Observable();\n    const contextManager = {\n        getContext: () => deepClone(context),\n        setContext: (newContext) => {\n            if (checkContext(newContext)) {\n                context = sanitize(ensureProperties(newContext, propertiesConfig, name));\n            }\n            else {\n                contextManager.clearContext();\n            }\n            changeObservable.notify();\n        },\n        setContextProperty: (key, property) => {\n            context = sanitize(ensureProperties({ ...context, [key]: property }, propertiesConfig, name));\n            changeObservable.notify();\n        },\n        removeContextProperty: (key) => {\n            delete context[key];\n            ensureProperties(context, propertiesConfig, name);\n            changeObservable.notify();\n        },\n        clearContext: () => {\n            context = {};\n            changeObservable.notify();\n        },\n        changeObservable,\n    };\n    return contextManager;\n}\n//# sourceMappingURL=contextManager.js.map","import { addTelemetryUsage } from '../telemetry';\nimport { monitor } from '../../tools/monitor';\nexport function defineContextMethod(getStrategy, contextName, methodName, usage) {\n    return monitor((...args) => {\n        if (usage) {\n            addTelemetryUsage({ feature: usage });\n        }\n        return getStrategy()[contextName][methodName](...args);\n    });\n}\nexport function bufferContextCalls(preStartContextManager, name, bufferApiCalls) {\n    preStartContextManager.changeObservable.subscribe(() => {\n        const context = preStartContextManager.getContext();\n        bufferApiCalls.add((startResult) => startResult[name].setContext(context));\n    });\n}\n//# sourceMappingURL=defineContextMethod.js.map","import { addEventListener } from '../../browser/addEventListener';\nimport { combine } from '../../tools/mergeInto';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\nconst CONTEXT_STORE_KEY_PREFIX = '_dd_c';\nconst storageListeners = [];\nexport function storeContextManager(configuration, contextManager, productKey, customerDataType) {\n    const storageKey = buildStorageKey(productKey, customerDataType);\n    storageListeners.push(addEventListener(configuration, window, \"storage\" /* DOM_EVENT.STORAGE */, ({ key }) => {\n        if (storageKey === key) {\n            synchronizeWithStorage();\n        }\n    }));\n    contextManager.changeObservable.subscribe(dumpToStorage);\n    const contextFromStorage = combine(getFromStorage(), contextManager.getContext());\n    if (!isEmptyObject(contextFromStorage)) {\n        contextManager.setContext(contextFromStorage);\n    }\n    function synchronizeWithStorage() {\n        contextManager.setContext(getFromStorage());\n    }\n    function dumpToStorage() {\n        localStorage.setItem(storageKey, JSON.stringify(contextManager.getContext()));\n    }\n    function getFromStorage() {\n        const rawContext = localStorage.getItem(storageKey);\n        return rawContext ? JSON.parse(rawContext) : {};\n    }\n}\nexport function buildStorageKey(productKey, customerDataType) {\n    return `${CONTEXT_STORE_KEY_PREFIX}_${productKey}_${customerDataType}`;\n}\nexport function removeStorageListeners() {\n    storageListeners.map((listener) => listener.stop());\n}\n//# sourceMappingURL=storeContextManager.js.map","import { storeContextManager } from '../context/storeContextManager';\nimport { SKIPPED } from '../../tools/abstractHooks';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\nimport { createContextManager } from '../context/contextManager';\nexport function startAccountContext(hooks, configuration, productKey) {\n    const accountContextManager = buildAccountContextManager();\n    if (configuration.storeContextsAcrossPages) {\n        storeContextManager(configuration, accountContextManager, productKey, 4 /* CustomerDataType.Account */);\n    }\n    hooks.register(0 /* HookNames.Assemble */, () => {\n        const account = accountContextManager.getContext();\n        if (isEmptyObject(account) || !account.id) {\n            return SKIPPED;\n        }\n        return {\n            account,\n        };\n    });\n    return accountContextManager;\n}\nexport function buildAccountContextManager() {\n    return createContextManager('account', {\n        propertiesConfig: {\n            id: { type: 'string', required: true },\n            name: { type: 'string' },\n        },\n    });\n}\n//# sourceMappingURL=accountContext.js.map","import { storeContextManager } from '../context/storeContextManager';\nimport { createContextManager } from '../context/contextManager';\nexport function startGlobalContext(hooks, configuration, productKey, useContextNamespace) {\n    const globalContextManager = buildGlobalContextManager();\n    if (configuration.storeContextsAcrossPages) {\n        storeContextManager(configuration, globalContextManager, productKey, 2 /* CustomerDataType.GlobalContext */);\n    }\n    hooks.register(0 /* HookNames.Assemble */, () => {\n        const context = globalContextManager.getContext();\n        return useContextNamespace ? { context } : context;\n    });\n    return globalContextManager;\n}\nexport function buildGlobalContextManager() {\n    return createContextManager('global context');\n}\n//# sourceMappingURL=globalContext.js.map","import { storeContextManager } from '../context/storeContextManager';\nimport { SKIPPED } from '../../tools/abstractHooks';\nimport { createContextManager } from '../context/contextManager';\nimport { isEmptyObject } from '../../tools/utils/objectUtils';\nexport function startUserContext(hooks, configuration, sessionManager, productKey) {\n    const userContextManager = buildUserContextManager();\n    if (configuration.storeContextsAcrossPages) {\n        storeContextManager(configuration, userContextManager, productKey, 1 /* CustomerDataType.User */);\n    }\n    hooks.register(0 /* HookNames.Assemble */, ({ eventType, startTime }) => {\n        const user = userContextManager.getContext();\n        const session = sessionManager.findTrackedSession(startTime);\n        if (session && session.anonymousId && !user.anonymous_id && !!configuration.trackAnonymousUser) {\n            user.anonymous_id = session.anonymousId;\n        }\n        if (isEmptyObject(user)) {\n            return SKIPPED;\n        }\n        return {\n            type: eventType,\n            usr: user,\n        };\n    });\n    hooks.register(1 /* HookNames.AssembleTelemetry */, ({ startTime }) => {\n        var _a;\n        return ({\n            anonymous_id: (_a = sessionManager.findTrackedSession(startTime)) === null || _a === void 0 ? void 0 : _a.anonymousId,\n        });\n    });\n    return userContextManager;\n}\nexport function buildUserContextManager() {\n    return createContextManager('user', {\n        propertiesConfig: {\n            id: { type: 'string' },\n            name: { type: 'string' },\n            email: { type: 'string' },\n        },\n    });\n}\n//# sourceMappingURL=userContext.js.map","// Use a const instead of const enum to avoid inlining the enum values in the bundle and save bytes\nexport const CustomerContextKey = {\n    userContext: 'userContext',\n    globalContext: 'globalContext',\n    accountContext: 'accountContext',\n};\n// Use a const instead of const enum to avoid inlining the enum values in the bundle and save bytes\nexport const ContextManagerMethod = {\n    getContext: 'getContext',\n    setContext: 'setContext',\n    setContextProperty: 'setContextProperty',\n    removeContextProperty: 'removeContextProperty',\n    clearContext: 'clearContext',\n};\n//# sourceMappingURL=contextConstants.js.map","import { BufferedObservable } from '../tools/observable';\nimport { trackRuntimeError } from './error/trackRuntimeError';\nconst BUFFER_LIMIT = 500;\nexport function startBufferingData(trackRuntimeErrorImpl = trackRuntimeError) {\n    const observable = new BufferedObservable(BUFFER_LIMIT);\n    const runtimeErrorSubscription = trackRuntimeErrorImpl().subscribe((error) => {\n        observable.notify({\n            type: 0 /* BufferedDataType.RUNTIME_ERROR */,\n            error,\n        });\n    });\n    return {\n        observable,\n        stop: () => {\n            runtimeErrorSubscription.unsubscribe();\n        },\n    };\n}\n//# sourceMappingURL=bufferedData.js.map"],"names":["instrumentMethod","targetPrototype","method","onPreCall","computeHandlingStack","original","noop","stopped","instrumentation","parameters","postCallCallback","callMonitored","callback","createHandlingStack","result","instrumentSetter","property","after","originalDescriptor","stoppedInstrumentation","target","value","setTimeout","instrumentationWrapper","_a","trackRuntimeError","Observable","observer","handleRuntimeError","originalError","stackTrace","rawError","computeRawError","clocksNow","ErrorSource","stopInstrumentingOnError","instrumentOnError","stopInstrumentingOnUnhandledRejection","instrumentUnhandledRejection","getGlobalObject","messageObj","url","line","column","errorObj","isError","computeStackTraceFromOnErrorMessage","e","makePublicApi","stub","publicApi","setDebugMode","defineGlobal","global","name","api","existingGlobalVariable","display","fn","catchUserErrors","displayAlreadyInitializedError","sdkName","initConfiguration","RawReportType","initReportObservable","configuration","apis","observables","createCspViolationReportObservable","reportTypes","createReportObservable","mergeObservables","observable","handleReports","monitor","reports","_","report","buildRawReportErrorFromReport","stop","addEventListener","event","buildRawReportErrorFromCspViolation","type","body","buildRawReportError","buildStack","message","safeTruncate","partial","sourceFile","lineNumber","columnNumber","toStackTraceString","TAG_SIZE_LIMIT","buildTags","env","service","version","datacenter","sdkVersion","variant","tags","buildTag","key","rawValue","tag","hasForbiddenCharacters","MORE_DETAILS","DOCS_ORIGIN","sanitizeTag","supportUnicodePropertyEscapes","sendToExtension","payload","globalObject","mergeInto","destination","source","circularReferenceChecker","createCircularReferenceChecker","flags","merged","i","getType","deepClone","combine","sources","set","has","array","getConnectivity","navigator","isServerError","status","tryToClone","response","MAX_ONGOING_BYTES_COUNT","ONE_KIBI_BYTE","MAX_ONGOING_REQUESTS","MAX_QUEUE_BYTES_COUNT","ONE_MEBI_BYTE","MAX_BACKOFF_TIME","ONE_MINUTE","INITIAL_BACKOFF_TIME","ONE_SECOND","sendWithRetryStrategy","state","sendStrategy","trackType","reportError","requestObservable","send","retryQueuedPayloads","scheduleRetry","onSuccess","onFailure","shouldRetryRequest","reason","previousQueue","newPayloadQueue","newRetryState","newBandwidthMonitor","queue","RECOMMENDED_REQUEST_BYTES_LIMIT","createHttpRequest","endpointBuilders","bytesLimit","retryState","endpointBuilder","onResponse","isExperimentalFeatureEnabled","ExperimentalFeature","fetchStrategy","fetchKeepAliveStrategy","sendBeaconStrategy","beaconUrl","reportBeaconError","hasReportedBeaconError","monitorError","isKeepAliveSupported","fetchUrl","getEventBridge","eventBridgeGlobal","getEventBridgeGlobal","eventType","viewId","view","bridgeSupports","capability","bridge","canUseEventBridge","currentHost","allowedHost","PageExitReason","createPageMayExitObservable","stopListeners","addEventListeners","stopBeforeUnloadListener","isPageExitReason","objectValues","MESSAGE_BYTES_LIMIT","createBatch","encoder","request","flushController","upsertBuffer","flushSubscription","flush","push","serializedMessage","estimatedMessageBytesCount","realMessageBytesCount","hasMessageFor","remove","removedMessage","messageBytesCount","addOrUpdate","jsonStringify","DOCS_TROUBLESHOOTING","upsertMessages","pageMightExit","encoderResult","formatPayloadFromEncoder","pendingMessages","computeBytesCount","data","FLUSH_DURATION_LIMIT","MESSAGES_LIMIT","isWorkerEnvironment","createFlushController","pageMayExitObservable","sessionExpireObservable","pageMayExitSubscription","sessionExpireSubscription","flushObservable","currentBytesCount","currentMessagesCount","flushReason","messagesCount","bytesCount","cancelDurationLimitTimeout","durationLimitTimeoutId","scheduleDurationLimitTimeout","clearTimeout","messageBytesCountDiff","DISCARDED","SKIPPED","abstractHooks","callbacks","hookName","cb","param","hookCallbacks","results","TelemetryType","ALLOWED_FRAME_URLS","METRIC_SAMPLE_RATE","TELEMETRY_EXCLUDED_SITES","INTAKE_SITE_US1_FED","MAX_TELEMETRY_EVENTS_PER_PAGE","telemetryObservable","getTelemetryObservable","BufferedObservable","startTelemetry","telemetryService","hooks","createEncoder","startTelemetryTransport","enabled","metricsEnabled","startTelemetryCollection","metricSampleRate","maxTelemetryEventsPerPage","alreadySentEventsByKind","telemetryEnabled","performDraw","telemetryEnabledPerType","runtimeEnvInfo","getRuntimeEnvInfo","rawEvent","metricName","kind","alreadySentEvents","stringifiedEvent","defaultTelemetryEventAttributes","toTelemetryEvent","startMonitorErrorCollection","addTelemetryError","getExperimentalFeatures","cleanupTasks","telemetrySubscription","endpoints","isTelemetryReplicationAllowed","telemetryBatch","task","INTAKE_SITE_STAGING","addTelemetryDebug","context","displayIfDebugEnabled","ConsoleApiName","formatError","addTelemetryConfiguration","addTelemetryMetrics","addTelemetryUsage","usage","computeStackTrace","scrubCustomerFrames","NO_ERROR_STACK_PRESENT_MESSAGE","frame","allowedFrameUrl","removeDuplicates","item","removeItem","index","isNonEmptyArray","END_OF_TIMES","CLEAR_OLD_VALUES_INTERVAL","cleanupHistoriesInterval","cleanupHistories","createValueHistory","expireDelay","maxEntries","entries","setInterval","clearExpiredValues","oldTimeThreshold","relativeNow","add","startTime","entry","endTime","find","options","closeActive","latestEntry","findAll","duration","addDuration","reset","clearInterval","SYNTHETICS_TEST_ID_COOKIE_NAME","SYNTHETICS_RESULT_ID_COOKIE_NAME","SYNTHETICS_INJECTS_RUM_COOKIE_NAME","willSyntheticsInjectRum","getInitCookie","getSyntheticsTestId","getSyntheticsResultId","isSyntheticsTest","VISIBILITY_CHECK_DELAY","SESSION_CONTEXT_TIMEOUT_DELAY","SESSION_TIME_OUT_DELAY","startSessionManager","productKey","computeTrackingType","trackingConsentState","renewObservable","expireObservable","sessionStore","startSessionStore","sessionContextHistory","buildSessionContext","clocksOrigin","session","detectSessionIdChange","trackActivity","trackVisibility","trackResume","reportUnexpectedSessionState","SESSION_NOT_TRACKED","expandOrRenewSession","expandSession","expandSessionWhenVisible","sessionStoreStrategyType","rawSession","cookieContext","SessionPersistence","retrieveSessionCookie","getSessionCookies","retrieveSessionFromLocalStorage","initialSessionState","sessionCreatedTime","sdkInitTime","dateNow","listener","changed","findLast","change","SESSION_STORE_KEY","sessionAge","newSessionState","toSessionState","time","cookie","sessionCookies","getCurrentSite","createIdentityEncoder","output","outputBytesCount","additionalEncodedBytesCount","AbstractLifeCycle","eventCallbacks","other","EVENT_RATE_LIMIT","createEventRateLimiter","onLimitReached","limit","eventCount","allowNextEvent","xhrObservable","xhrContexts","initXhrObservable","createXhrObservable","stopInstrumentingStart","openXhr","stopInstrumentingSend","call","sendXhr","stopInstrumentingAbort","abortXhr","xhr","normalizeUrl","handlingStack","startContext","hasBeenReported","stopInstrumentingOnReadyStateChange","onEnd","unsubscribeLoadEndListener","completeContext","elapsed","timeStampNow","shallowClone","readBytesFromStream","stream","reader","chunks","concatBuffers","fetchObservable","responseBodyActionGetters","initFetchObservable","responseBodyAction","createFetchObservable","beforeSend","onPostCall","input","init","methodFromParams","startClocks","responsePromise","afterSend","_b","error","responseBodyCondition","action","getter","clonedResponse","bytes","consoleObservablesByApi","initConsoleObservable","consoleObservables","createConsoleObservable","originalConsoleApi","globalConsole","params","buildConsoleLog","formatConsoleParameters","firstErrorParam","sanitize","formatErrorMessage","BUFFER_LIMIT","createBoundedBuffer","buffer","arg","checkContext","maybeContext","isValid","ensureProperties","propertiesConfig","newContext","required","isDefined","createContextManager","changeObservable","contextManager","defineContextMethod","getStrategy","contextName","methodName","args","bufferContextCalls","preStartContextManager","bufferApiCalls","startResult","CONTEXT_STORE_KEY_PREFIX","storageListeners","storeContextManager","customerDataType","storageKey","buildStorageKey","synchronizeWithStorage","dumpToStorage","contextFromStorage","getFromStorage","isEmptyObject","rawContext","startAccountContext","accountContextManager","buildAccountContextManager","account","startGlobalContext","useContextNamespace","globalContextManager","buildGlobalContextManager","startUserContext","sessionManager","userContextManager","buildUserContextManager","user","CustomerContextKey","ContextManagerMethod","startBufferingData","trackRuntimeErrorImpl","runtimeErrorSubscription"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]}